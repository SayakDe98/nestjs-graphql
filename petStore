Youtube link: https://youtu.be/geYvdbpo3cA
What we will build:
We will build a pet store API

Imagine we had a client who had a pet store we will check who are all the pets, their owners of those pets, create owners and pets.

We will install nestjs/cli
and then nest new <appname>
->package choose any npm or yarn

Now install few dependencies forgraphql
npm install @nestjs/graphql graphql-tools graphql apollo-server-express

Then run command:
nest g module pets which is used to generate pets module

Now app module has a pets module and now if we open up pets module we can see we only have module
but now if we generate service then inside it we also have secrive

nest g resolver pets this is used to generate resolver

Now let's go back to app module and add import for graphql module:
first do npm install @nestjs/apollo then:

import {ApolloDriver,ApolloDriverConfig} from '@nestjs/apollo';


@Module({
  imports: [GraphQLModule.forRoot<ApolloDriverConfig>({
  driver: ApolloDriver,
    autoSchemaFile: join(process.cwd(), 'src/schema.gql'),
  }), PetsModule],
  
  We can either go code first or schema first :
  IF code first then we write ts classes and from there nestjs figures out what is the schema and autogenerate that for you.
  That's why we have this autoSchemaFile property which generates graphql schema automatically
  into this file. so we are wrting code and graphql schema gets autogenerated from the code.
  
  Schema first is inverse of that. If you are someone who knows graphql really well then use this.
  That schema will auto generate ts definitions that nestjs needs to run the app.
  
lets stick with Code first approach because we are using typeorm for writing schema and graphql object types

In pets directory let's create a file called pets.entity.ts
Inside it :
import { Field, Int, ObjectType } from "@nestjs/graphql";

@ObjectType()
export class Pet {
    @Field(type => Int)
    id: number;

    @Field()
    name: string;

    @Field({nullable: true})
    type?: string;
}

graphql needs to know type is Int which is scalar type
for string thats not needed
for type? we must define a property of nullable true for graphql to understand it can be null

Now let's go to pets.service.ts 
import { Injectable } from '@nestjs/common';
import { Pet } from './pets.entity';

@Injectable()
export class PetsService {
    async findAll(): Promise<Pet[]> {
        const pet = new Pet();//make an object
        pet.id = 1;
        pet.name = "Mambo";

        return [pet];
    }
}

Inside pets resolver:
import { Query } from '@nestjs/graphql';
import { Resolver } from '@nestjs/graphql';
import { Pet } from './pets.entity';
import { PetsService } from './pets.service';

@Resolver(of => Pet)//of is used to define the type of resolve we are doing
export class PetsResolver {
    constructor(private petsService: PetsService) {}

    //first query:
    @Query(returns => [Pet])//import from @nestjs/graphql.returns => [Pet] returns array of pets
    pets(): Promise<Pet[]> {
        return this.petsService.findAll();
    }
}

Now we should run our nestjs using command: nest start or npm run start
Then if it is succesffuly connected then go to localhost:3000/graphql and we will see a playground there.
Now if we click on schema we will see:type Pet {
  id: Int!
  name: String!
  type: String
}

type Query {
  pets: [Pet!]!
}

We can also see the schema in schema.gql which is auto generated.

Now let's write a query in localhost:3000/graphql:
# Write your query or mutation here
query {
  pets {
    name
  }
}

Output we got is:
{
  "data": {
    "pets": [
      {
        "name": "Mambo"
      }
    ]
  }
}

Now let's do database integration with typeorm:
npm install @nestjs/typeorm typeorm sqlite3
sqlite3 can be replaced by mysql or postgresql or mongodb

We need to include typeormmodule config as well in app.module.ts
@Module({
  imports: [GraphQLModule.forRoot<ApolloDriverConfig>({
    driver: ApolloDriver,
    autoSchemaFile: join(process.cwd(), 'src/schema.gql'),
  }), 
  TypeOrmModule.forRoot({
    type: 'sqlite',//means using sqlite
    database: ':memory:',//means use memory whenever we restart server data refreshes
    entities: ['dist/**/*.entity{.ts,.js}'],//look for entiities in that directory
    synchronize: true,//sychronize true means all changes will get reflected means tables will be created when starting server
  }), 
  PetsModule],
  controllers: [AppController],
  providers: [AppService],
})


Now inside pet.module.ts we need to mention this :
 imports: [TypeOrmModule.forFeature([Pet])],
 
 What it does is inside our pet.service.ts we can use @InjectRepository of type Pet 
     constructor(@InjectRepository(Pet) private petsRepository: Repository<Pet>) {}

inside pet.service.ts:
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Pet } from './pets.entity';

@Injectable()
export class PetsService {
    constructor(@InjectRepository(Pet) private petsRepository: Repository<Pet>) {}

    async findAll(): Promise<Pet[]> {
        return this.petsRepository.find(); //SELECT * pet
    }
}

Now we replaced dummy data with query to find all pets in database

We now need to create dto(data transfer object) in a folder called dto:
import { Field, InputType } from "@nestjs/graphql";

@InputType()//input types are dto's in graphql
export class CreatePetInput {
    
    @Field()
    name: string;

    @Field({nullable: true})
    type?: string;
}

inside pet.service.ts:
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { CreatePetInput } from './dto/create-pet.input';
import { Pet } from './pets.entity';

@Injectable()
export class PetsService {
    constructor(@InjectRepository(Pet) private petsRepository: Repository<Pet>) {}

    createPet(createPetInput: CreatePetInput): Promise<Pet> {//this is a dto
        const newPet = this.petsRepository.create(createPetInput);//newPet = new Pet(); new.name = input.name

        return this.petsRepository.save(newPet); //insert into database
    }

    async findAll(): Promise<Pet[]> {
        return this.petsRepository.find(); //SELECT * pet
    }
}


Now we need to create a mutation in pets.resolver.ts:
import { Args, Mutation, Query } from '@nestjs/graphql';
import { Resolver } from '@nestjs/graphql';
import { CreatePetInput } from './dto/create-pet.input';
import { Pet } from './pets.entity';
import { PetsService } from './pets.service';

@Resolver(of => Pet)//of is used to define the type of resolve we are doing
export class PetsResolver {
    constructor(private petsService: PetsService) {}

    //first query:
    @Query(returns => [Pet])//import from @nestjs/graphql.returns => [Pet] returns array of pets
    pets(): Promise<Pet[]> {
        return this.petsService.findAll();
    }

    @Mutation(returns => Pet)
    createPet(@Args('createPetInput') createPetInput: CreatePetInput): Promise<Pet> {
        return this.petsService.createPet(createPetInput);
    }
}

Now we will see changes in schema.gql:
# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Pet {
  id: Int!
  name: String!
  type: String
}

type Query {
  pets: [Pet!]!
}

type Mutation {
  createPet(createPetInput: CreatePetInput!): Pet!
}

input CreatePetInput {
  name: String!
  type: String
}

if we change args to test then schema gets changed to test.
A Mutation is a GraphQL Operation that allows you to insert new data or modify the existing data on the server-side. You can think of GraphQL Mutations as the equivalent of POST , PUT , PATCH and DELETE requests in REST.

Now we go to localhost: graphql and refresh page then:
# Write your query or mutation here
mutation {
  createPet(createPetInput: {
    name: "Mambo"
  }) {
    name,
    id
  }
}

Output;
{
  "data": {
    "createPet": {
      "name": "Mambo",
      "id": 1
    }
  }
}

Now it is saved in database:
if we run the pet query then we get mambo:
query {
  pets {
    name,
    id
  }
}

Now create another pet:
mutation {
  createPet(createPetInput: {
    name: "Dumbo"
  }) {
    name,
    id
  }
}

then run query to find all pets we get:
{
  "data": {
    "pets": [
      {
        "name": "Mambo",
        "id": 1
      },
      {
        "name": "Dumbo",
        "id": 2
      }
    ]
  }
}


Now we will be using automatic validators:
npm install class-validator class-transformer
Now let's come back to main.ts we will be using pipes.
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
 
  app.useGlobalPipes(new ValidationPipe());

  await app.listen(3000);
}
bootstrap();

Now we can go back to create-pet.input.ts
Now we can add IsAlpha() over name property.

import { Field, InputType } from '@nestjs/graphql';
import { IsAlpha } from 'class-validator';

@InputType()//input types are dto's in graphql
export class CreatePetInput {
    
    @IsAlpha()
    @Field()
    name: string;

    @Field({nullable: true})
    type?: string;
}

Now if we try to set name: "12708473042" then we will get error because it is number and not alphabet.

Now let's create findOne query:
In pets service:

import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { CreatePetInput } from './dto/create-pet.input';
import { Pet } from './pets.entity';

@Injectable()
export class PetsService {
    constructor(@InjectRepository(Pet) private petsRepository: Repository<Pet>) {}

    createPet(createPetInput: CreatePetInput): Promise<Pet> {//this is a dto
        const newPet = this.petsRepository.create(createPetInput);//newPet = new Pet(); new.name = input.name

        return this.petsRepository.save(newPet); //insert into database
    }

    async findAll(): Promise<Pet[]> {
        return this.petsRepository.find(); //SELECT * pet
    }

    findOne(id: number): Promise<Pet> {
        return this.petsRepository.findOneOrFail({where:{
            id
        }});
    } 
}

In pet resolver:
 @Query(returns => Pet)
    getPet(@Args('id', { type: () => Int }) id: number): Promise<Pet> {
        return this.petsService.findOne(id);
    }
    
Till now we were creating these ourselves
now lets do that automatically:
nest g resource owners
After running that we will see few options:
select graphql(code first)
now we see would you like to generate crud entry points?//this is boiler plate for crud
We will select Y

We can see after doing that basic crud is created.

The only thing that is missing is when we go to owner.service.ts we will see:
All returns string because it doesn't know how to hook it upto type orm

We can see we got entity. 
we also got dto for creating and updating

Now let's do some changes in Owner entity like we want it to be:
import { ObjectType, Field, Int } from '@nestjs/graphql';
import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity()
@ObjectType()
export class Owner {
  
  @PrimaryGeneratedColumn()
  @Field(type => Int)
  id: number;

  @Column()
  @Field()
  name: string;
}

Now let's add some relations between pets and owners
owners should have some pets 
It is basically boiler plate generator for crud

If we want to do referencing we can provide exports
import { Module } from '@nestjs/common';
import { OwnersService } from './owners.service';
import { OwnersResolver } from './owners.resolver';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Owner } from './entities/owner.entity';

@Module({
  imports: [TypeOrmModule.forFeature([Owner])],
  providers: [OwnersResolver, OwnersService],
  exports: [OwnersService]
})
export class OwnersModule {}

and now we can go to pet module
import { Module } from '@nestjs/common';
import { PetsService } from './pets.service';
import { PetsResolver } from './pets.resolver';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Pet } from './entities/pets.entity';
import { OwnersModule } from 'src/owners/owners.module';

@Module({
  imports: [TypeOrmModule.forFeature([Pet]), OwnersModule],
  providers: [PetsService, PetsResolver]
})
export class PetsModule {}

and now we can go to pet service
    constructor(@InjectRepository(Pet) private petsRepository: Repository<Pet>, private ownersService: OwnersService) {}

Now we have access to those methods in owner service
come to pet service and write:
 getOwner(ownerId: number): Promise<Owner> {
        return this.ownersService.findOne(ownerId);
    }
    
Now in pet resolver:
  @ResolveField(returns => Owner)
    owner(@Parent() pet: Pet): Promise<Owner> {
        return this.petsService.getOwner(pet.ownerId);
    } 
    
    Parent is used for doing nesting of query it is like referencing.
    ResolveField is also used for creating nested queries
    @Resolver((of=> Pet) was needed for this. It helps us do parent of type Pet
    
    Also in create-pet :
    import { Field, InputType, Int } from '@nestjs/graphql';
import { IsAlpha } from 'class-validator';

@InputType()//input types are dto's in graphql
export class CreatePetInput {
    
    @IsAlpha()
    @Field()
    name: string;

    @Field({nullable: true})
    type?: string;

    @Field(type => Int)
    ownerId: number
}

Now we need to create an owner first 
then create a pet

create owner:
mutation {
  createOwner(createOwnerInput: {
    name: "Marius",
  })
  {
    id,
    name
  }
}

create pet:
mutation {
  createPet(createPetInput: {
    name: "Dumbo",
    ownerId: 1
  })
  {
    id,
    name
  }
}

getPet;
query {
  getPet(id: 1) {
    name,
    id,
    owner {
      name,
      id
    }
  }
}

getOwners and their pets:
query {
  owners {
    name,
    id,
    pets {
      name,
      id
    }
  }
}
